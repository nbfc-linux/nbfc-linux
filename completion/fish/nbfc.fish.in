# This script was generated by argparse-shell-complete.
# argparse-shell-complete: A tool that creates robust and reliable autocompletion scripts using Python's argparse module.
# For more information, visit: https://github.com/argparse-shell-complete/argparse-shell-complete

function _nbfc_command
  printf "%s\t%s\n" \
    start 'Start the service' \
    stop 'Stop the service' \
    restart 'Restart the service' \
    status 'Show the service status' \
    config 'List or apply configs' \
    set 'Control fan speed' \
    wait-for-hwmon 'Wait for /sys/class/hwmon/hwmon* files' \
    help 'Show help'
end

function _nbfc_fish_complete_filedir
  # Function for completing files or directories
  #
  # Options:
  #   -d|--description=DESC   The description for completed entries
  #   -c|--comp=STR           Complete STR instead of current command line argument
  #   -D|--directories        Only complete directories
  #   -C|--cd=DIR             List contents in DIR
  #
  # This function is made out of /usr/share/fish/functions/__fish_complete_directories.fish

  argparse --max-args 0 'd/description=' 'c/comp=' 'D/directories' 'C/cd=' -- $argv || return 1

  set -l comp
  set -l desc

  if set -q _flag_description[1]
    set desc $_flag_description
  else if set -g _flag_directories
    set desc 'Directory'
  end

  if set -q _flag_comp[1]
    set comp $_flag_comp
  else
    set comp (commandline -ct | string replace -r -- '^-[^=]*=' '')
  end

  if set -q _flag_cd[1]
    pushd $_flag_cd || return 1
  end

  set -l files (complete -C"'' $comp")

  if set -q _flag_cd[1]
    popd
  end

  if set -q files[1]
    if set -q _flag_directories[1]
      set files (printf "%s\n" $files | string match -r '.*/$')
    end

    printf "%s\n" $files\t"$desc"
  end
end

function _nbfc_fish_helper
  # ===========================================================================
  #
  # This function implements the parsing of options and positionals in the Fish shell.
  #
  # Usage: __fish_helper <OPTIONS> <COMMAND> [ARGS...]
  #
  # The first argument is a comma-seperated list of options that the parser should know about.
  # Short options (-o), long options (--option), and old-style options (-option) are supported.
  #
  # If an option takes an argument, it is suffixed by '='.
  # If an option takes an optional argument, it is suffixed by '=?'.
  #
  # For example:
  #   __fish_helper '-f,--flag,-old-style,--with-arg=,--with-optional=?'
  #
  #   Here, -f, --flag and -old-style don't take options, --with-arg requires an
  #   argument and --with-optional takes an optional argument.
  #
  # COMMANDS
  #   positional_contains <NUM> <WORDS...>
  #     Checks if the positional argument number NUM is one of WORDS.
  #     NUM counts from one.
  #
  #   has_option <OPTIONS...>
  #     Checks if a option given in OPTIONS is passed on commandline.
  #
  #   num_of_positionals [<OPERATOR> <NUMBER>]
  #     Checks the number of positional arguments.
  #     If no arguments are provided, print the total count of positional arguments.
  #     If two arguments are provided, the first argument should be one of
  #     the comparison operators: '-lt', '-le', '-eq', '-ne', '-gt', '-ge'.
  #     Returns 0 if the count of positional arguments matches the
  #     specified NUMBER according to the comparison operator, otherwise returns 1.
  #
  # ===========================================================================

  set -l func '__fish_helper'

  set -l short_opts_with_arg
  set -l long_opts_with_arg
  set -l old_opts_with_arg

  set -l short_opts_without_arg
  set -l long_opts_without_arg
  set -l old_opts_without_arg

  set -l short_opts_with_optional_arg
  set -l long_opts_with_optional_arg
  set -l old_opts_with_optional_arg

  set -l option

  # ===========================================================================
  # Parsing of OPTIONS argument
  # ===========================================================================

  if test (count $argv) -lt 1
  echo "$func: missing OPTIONS argument" >&2
  return 1
  end

  if test -n "$argv[1]"
  for option in (string split -- ',' $argv[1])
    # Using one big switch case is the fastest way
    switch $option
      case '--?*=';   set -a long_opts_with_arg           (string replace -- '='  '' $option)
      case '--?*=\?'; set -a long_opts_with_optional_arg  (string replace -- '=?' '' $option)
      case '--?*';    set -a long_opts_without_arg        $option

      case '-?=';     set -a short_opts_with_arg          (string replace -- '='  '' $option)
      case '-?=\?';   set -a short_opts_with_optional_arg (string replace -- '=?' '' $option)
      case '-?';      set -a short_opts_with_arg          $option

      case '-??*=';   set -a old_opts_with_arg            (string replace -- '='  '' $option)
      case '-??*=\?'; set -a old_opts_with_optional_arg   (string replace -- '=?' '' $option)
      case '-??*';    set -a old_opts_without_arg         $option

      case '*'
        echo "$func: argv[1]: '$option' is not a short, long or old-style option" >&2
        return 1
    end
  end
  end

  set -e argv[1]

  # ===========================================================================
  # Parsing of options and positionals
  # ===========================================================================

  set -l positionals
  set -l having_options

  set -l cmdline (commandline -poc)
  set -l cmdline_count (count $cmdline)

  set -l argi 2 # cmdline[1] is command name
  while test $argi -le $cmdline_count
  set -l arg "$cmdline[$argi]"
  set -l have_trailing_arg (test $argi -lt $cmdline_count && echo true || echo false)

  switch $arg
    case '-'
      set -a positionals -
    case '--'
      for argi in (seq (math $argi + 1) $cmdline_count)
        set -a positionals $cmdline[$argi]
      end
      break
    case '--*'
      for option in $long_opts_with_arg $long_opts_without_arg $long_opts_with_optional_arg
        if string match -q -- "$option=*" $arg
          set -a having_options $option
          break
        else if string match -q -- $option $arg
          if contains -- $option $long_opts_with_arg
            if $have_trailing_arg
              set -a having_options $option
              set argi (math $argi + 1)
            end
          else
            set -a having_options $option
          end
          break
        end
      end
    case '-*'
      set -l have_match false

      for option in $old_opts_with_arg $old_opts_without_arg $old_opts_with_optional_arg
        if string match -q -- "$option=*" $arg
          set -a having_options $option
          set have_match true
          break
        else if string match -q -- $option $arg
          if contains -- $option $old_opts_with_arg
            if $have_trailing_arg
              set -a having_options $option
              set argi (math $argi + 1)
            end
          else
            set -a having_options $option
          end

          set have_match true
          break
        end
      end

      if not $have_match
        set -l arg_length (string length -- $arg)
        set -l i 2
        set is_end false
        while not $is_end && test $i -le $arg_length
          set -l char (string sub -s $i -l 1 -- "$arg")
          set -l have_trailing_chars (test $i -lt $arg_length && echo true || echo false)

          for option in $short_opts_with_arg $short_opts_without_arg $short_opts_with_optional_arg
            set -l option_char (string sub -s 2 -l 1 -- $option)

            if test "$char" = "$option_char"
              if contains -- $option $short_opts_with_arg
                if $have_trailing_chars
                  set -a having_options $option
                  set is_end true
                else if $have_trailing_arg
                  set -a having_options $option
                  set argi (math $argi + 1)
                  set is_end true
                end
              else if contains -- $option $short_opts_with_optional_arg
                set -a having_options $option

                if $have_trailing_chars
                  set is_end true
                end
              else
                set -a having_options $option
              end

              break
            end
          end

          set i (math $i + 1)
        end
      end
    case '*'
      set -a positionals $arg
  end

  set argi (math $argi + 1)
  end

  # ===========================================================================
  # Commands
  # ===========================================================================

  if test (count $argv) -eq 0
  echo "$func: missing command" >&2
  return 1
  end

  set -l cmd "$argv[1]"
  set -e argv[1]

  switch $cmd
  case 'positional_contains'
    if test (count $argv) -eq 0
      echo "$func: positional_contains: argv[3]: missing number" >&2
      return 1
    end

    set -l positional_num $argv[1]
    set -e argv[1]
    contains -- $positionals[$positional_num] $argv && return 0 || return 1
  case 'has_option'
    for option in $having_options
      contains -- $option $argv && return 0
    end

    return 1
  case 'num_of_positionals'
    if test (count $argv) -eq 0
      count $positionals
    else if test (count $argv) -eq 2
      if contains -- $argv[1] -lt -le -eq -ne -gt -ge;
        test (count $positionals) $argv[1] $argv[2] && return 0 || return 1
      else
        echo "$func: num_of_positionals: $argv[1]: unknown operator" >&2
        return 1
      end
    else if test (count $argv) -eq 1
      echo "$func: num_of_positionals: $argv[1]: missing operand" >&2
      return 1
    end
  case '*'
    echo "$func: argv[2]: invalid command" >&2
    return 1
  end
end

set -l prog "nbfc"
set -l helper "_nbfc_fish_helper"

# command nbfc
set -l options "--help,-h,--version"
set -l guard000 "not $helper '$options' has_option --help -h && $helper '$options' num_of_positionals -eq 0"
set -l guard001 "not $helper '$options' has_option --version && $helper '$options' num_of_positionals -eq 0"
set -l guard002 "$helper '$options' num_of_positionals -eq 0"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -l version -d "show program's version number and exit" -f
complete -c $prog -n $guard002 -d Commands -f -a '(_nbfc_command)'

# command nbfc start
set -l options "--help,-h,--version,--help,-h,-r,--read-only"
set -l guard000 "$helper '$options' positional_contains 1 start && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 start && not $helper '$options' has_option -r --read-only"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s r -l read-only -d 'Start in read-only mode' -f

# command nbfc stop
set -l options "--help,-h,--version,--help,-h"
set -l guard000 "$helper '$options' positional_contains 1 stop && not $helper '$options' has_option --help -h"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f

# command nbfc restart
set -l options "--help,-h,--version,--help,-h,-r,--read-only"
set -l guard000 "$helper '$options' positional_contains 1 restart && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 restart && not $helper '$options' has_option -r --read-only"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s r -l read-only -d 'Restart in read-only mode' -f

# command nbfc status
set -l options "--help,-h,--version,--help,-h,-a,--all,-s,--service,-f=,--fan=,-w=,--watch="
set -l guard000 "$helper '$options' positional_contains 1 status && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 status && not $helper '$options' has_option -s --service -f --fan -a --all"
set -l guard002 "$helper '$options' positional_contains 1 status && not $helper '$options' has_option -a --all -f --fan -s --service"
set -l guard003 "$helper '$options' positional_contains 1 status && not $helper '$options' has_option -a --all -s --service -f --fan"
set -l guard004 "$helper '$options' positional_contains 1 status && not $helper '$options' has_option -w --watch"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s a -l all -d 'Show service and fan status (default)' -f
complete -c $prog -n $guard002 -s s -l service -d 'Show service status' -f
complete -c $prog -n $guard003 -s f -l fan -d 'Show status of fan (zero based)' -x
complete -c $prog -n $guard004 -s w -l watch -d 'Show status periodically' -x

# command nbfc config
set -l options "--help,-h,--version,--help,-h,-l,--list,-s=,--set=,-a=,--apply=,-r,--recommend"
set -l guard000 "$helper '$options' positional_contains 1 config && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 config && not $helper '$options' has_option -s --set -a --apply -r --recommend -l --list"
set -l guard002 "$helper '$options' positional_contains 1 config && not $helper '$options' has_option -l --list -a --apply -r --recommend -s --set"
set -l guard003 "$helper '$options' positional_contains 1 config && not $helper '$options' has_option -l --list -s --set -r --recommend -a --apply"
set -l guard004 "$helper '$options' positional_contains 1 config && not $helper '$options' has_option -l --list -s --set -a --apply -r --recommend"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s l -l list -d 'List all available configs (default)' -f
complete -c $prog -n $guard002 -s s -l set -d 'Set a config' -x -a '(_nbfc_fish_complete_filedir -C @DATADIR@/nbfc/configs)'
complete -c $prog -n $guard003 -s a -l apply -d 'Set a config and enable fan control' -x -a '(_nbfc_fish_complete_filedir -C @DATADIR@/nbfc/configs)'
complete -c $prog -n $guard004 -s r -l recommend -d 'List configs which may work for your device' -f

# command nbfc set
set -l options "--help,-h,--version,--help,-h,-a,--auto,-s=,--speed=,-f=,--fan="
set -l guard000 "$helper '$options' positional_contains 1 set && not $helper '$options' has_option --help -h"
set -l guard001 "$helper '$options' positional_contains 1 set && not $helper '$options' has_option -s --speed -a --auto"
set -l guard002 "$helper '$options' positional_contains 1 set && not $helper '$options' has_option -a --auto -s --speed"
set -l guard003 "$helper '$options' positional_contains 1 set && not $helper '$options' has_option -f --fan"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f
complete -c $prog -n $guard001 -s a -l auto -d "Set fan speed to 'auto'" -f
complete -c $prog -n $guard002 -s s -l speed -d 'Set fan speed to PERCENT' -x
complete -c $prog -n $guard003 -s f -l fan -d 'Fan index (zero based)' -x -a '(nbfc complete-fans)'

# command nbfc wait-for-hwmon
set -l options "--help,-h,--version,--help,-h"
set -l guard000 "$helper '$options' positional_contains 1 wait-for-hwmon && not $helper '$options' has_option --help -h"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f

# command nbfc help
set -l options "--help,-h,--version,--help,-h"
set -l guard000 "$helper '$options' positional_contains 1 help && not $helper '$options' has_option --help -h"
complete -c $prog -n $guard000 -s h -l help -d 'show this help message and exit' -f

# vim: ft=fish ts=2 sts=2 sw=2 et
